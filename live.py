# -*- coding: utf-8 -*-
"""hand_gestures.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZBavqXISvJ2iCbf2n7-JMA-fLx6DH5d1

<a href="https://colab.research.google.com/github/saulolks/HandTracking/blob/master/hand_gestures.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Handtracking and Gesture Recognition

## Entrega 2
### Aplicação de filtros para obtenção do objeto de interesse removendo partes desnecessárias da imagem.
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import numpy as np
from glob import glob
# %matplotlib inline
from matplotlib import pyplot as plt
# from google.colab.patches import cv2_imshow
from pyefd import elliptic_fourier_descriptors

# !git clone https://github.com/saulolks/HandTracking

wsize_open = 13
wsize_gaussian = 13

y_min = 54
y_max = 137
crmin = 135
crmax = 174
cbmin = 80
cbmax = 125

headcascade = cv2.CascadeClassifier('face.xml')
backSub = cv2.createBackgroundSubtractorKNN(history=500, dist2Threshold=30)
kernel = np.ones((wsize_open, wsize_open), np.uint8)

def efd_feature(contour):
    coeffs = elliptic_fourier_descriptors(contour, order=10, normalize=True)
    return coeffs.flatten()[3:]

"""### Transformando RGB em YCrCb"""
for dir in ['A', 'B', 'C', 'Five', 'Point', 'V']:
    count = 0
    for filepath in glob('Database/'+dir+'/**'):
        print(filepath)
        original = cv2.imread(filepath, -1)
        image = cv2.cvtColor(original, cv2.COLOR_BGR2YCR_CB)

        fig, axes = plt.subplots(1, 2, figsize=(12, 6))
        ax = axes.ravel()
        #ax[0].imshow(cv2.cvtColor(original, cv2.COLOR_BGR2RGB))
        #ax[0].set_title('Original')
        #ax[0].set_axis_off()

        #ax[1].imshow(image)
        #ax[1].set_title('YCrCb')
        #ax[1].set_axis_off()

        """### Converte em tons de cinza para detectar face
        Localiza a face na imagem em tons de cinza.
        """

        image_gray = cv2.cvtColor(original, cv2.COLOR_BGR2GRAY)
        faces = headcascade.detectMultiScale(image_gray, 1.3, 5)

        fig, axes = plt.subplots(1, 2, figsize=(12, 6))
        ax = axes.ravel()
        #ax[0].imshow(cv2.cvtColor(original, cv2.COLOR_BGR2RGB))
        #ax[0].set_title('Original')
        #ax[0].set_axis_off()

        #ax[1].imshow(image_gray, cmap='gray')
        #ax[1].set_title('Gray')
        #ax[1].set_axis_off()

        """### Divide imagem YCrCb em 3 canais distintos"""

        y, cr, cb = cv2.split(image)

        fig, axes = plt.subplots(1, 3, figsize=(12, 6))
        ax = axes.ravel()

        #ax[0].imshow(y)
        #ax[0].set_title('Y')
        #ax[0].set_axis_off()

        #ax[1].imshow(cr)
        #ax[1].set_title('Cr')
        #ax[1].set_axis_off()

        #ax[2].imshow(cb)
        #ax[2].set_title('Cb')
        #ax[2].set_axis_off()

        """### Binarização"""

        _, y = cv2.threshold(y, y_min, y_max, cv2.THRESH_BINARY)
        _, cr = cv2.threshold(cr, crmin, crmax, cv2.THRESH_BINARY)
        _, cb = cv2.threshold(cb, cbmin, cbmax, cv2.THRESH_BINARY)

        fig, axes = plt.subplots(1, 3, figsize=(12, 6))
        ax = axes.ravel()

        #ax[0].imshow(y)
        #ax[0].set_title('Y')
        #ax[0].set_axis_off()

        #ax[1].imshow(cr)
        #ax[1].set_title('Cr')
        #ax[1].set_axis_off()

        #ax[2].imshow(cb)
        #ax[2].set_title('Cb')
        #ax[2].set_axis_off()

        """### Morfologia
        Utiliza transformações morfológicas de abertura para remoção de pequenos artefatos na imagem.
        """

        y = cv2.morphologyEx(y, cv2.MORPH_OPEN, kernel)
        cr = cv2.morphologyEx(cr, cv2.MORPH_OPEN, kernel)
        cb = cv2.morphologyEx(cb, cv2.MORPH_OPEN, kernel)

        fig, axes = plt.subplots(1, 3, figsize=(12, 6))
        ax = axes.ravel()

        #ax[0].imshow(y)
        #ax[0].set_title('Y')
        #ax[0].set_axis_off()

        #ax[1].imshow(cr)
        #ax[1].set_title('Cr')
        #ax[1].set_axis_off()

        #ax[2].imshow(cb)
        #ax[2].set_title('Cb')
        #ax[2].set_axis_off()

        """### Merge"""

        """### Juntando os filtros e binarizando"""

        img = cv2.merge((y,cr,cb))

        img1 = img.copy()

        img2= cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
        _, img3= cv2.threshold(img2, 100, 255, cv2.THRESH_BINARY)

        fig, axes = plt.subplots(1, 2, figsize=(12, 6))
        ax = axes.ravel()

        #ax[0].imshow(img1)
        #ax[0].set_title('YCrCb merged')
        #ax[0].set_axis_off()

        #ax[1].imshow(img3, cmap='gray')
        #ax[1].set_title('Binarizada')
        #ax[1].set_axis_off()

        """### Eliminação de ruídos e face"""

        mask = backSub.apply(image)
        img4 = cv2.bitwise_and(mask, img3)
        img5 = cv2.medianBlur(img4, wsize_gaussian)
        img5 = cv2.morphologyEx(img5, cv2.MORPH_OPEN, kernel)

        fig, axes = plt.subplots(1, 2, figsize=(12, 6))
        ax = axes.ravel()

        #ax[0].imshow(img5, cmap='gray')
        #ax[0].set_title('Filtro Média')
        #ax[0].set_axis_off()

        marge = 30
        for (x, y, w, h) in faces:
            cv2.rectangle(img5, (x - marge, y - h + marge), (x + marge + w, y + marge + h), (0, 0, 0), -1)

        #ax[1].imshow(img5, cmap='gray')
        #ax[1].set_title('Face removida')
        #ax[1].set_axis_off()

        """## Entrega 3

        ### Encontrando contornos
        """

        segment = img5.copy()
        segment = cv2.cvtColor(segment, cv2.COLOR_GRAY2BGR)
        boundbox = img5.copy()
        boundbox = cv2.cvtColor(boundbox, cv2.COLOR_GRAY2BGR)
        binary = img5.copy()
        hand_only = None
        position = None

        contours, _ = cv2.findContours(binary, 1, 2)

        if len(contours) > 0:
            cnt = contours[0]
            max_area = cv2.contourArea(cnt)

            coeffs = []
            for cont in contours:
                coeffs.append(elliptic_fourier_descriptors(np.squeeze(cnt), order=10))
                if cv2.contourArea(cont) > max_area:
                    cnt = cont
                    max_area = cv2.contourArea(cont)
                    
            epsilon = 0.01 * cv2.arcLength(cnt, True)
            approx = cv2.approxPolyDP(cnt, epsilon, True)
            hull = cv2.convexHull(approx)
            x, y, w, h = cv2.boundingRect(hull)
            
            hand_only = binary[y:y + h, x:x + w]
            cv2.drawContours(segment, [approx], -1, (0, 0, 255), 5)
            cv2.rectangle(boundbox, (x, y), (x + w, y + h), (255, 0, 0),  5)

        fig, axes = plt.subplots(1, 3, figsize=(12, 6))
        ax = axes.ravel()

        #ax[0].imshow(segment)
        #ax[0].set_title('Segmentação')
        #ax[0].set_axis_off()

        #ax[1].imshow(boundbox)
        #ax[1].set_title('Caixa delimitadora')
        #ax[1].set_axis_off()

        #ax[2].imshow(hand_only, cmap='gray')
        #ax[2].set_title('Apenas a mão')
        #ax[2].set_axis_off()
        cv2.imshow("image", original)
        cv2.imshow("thresholding", img1)
        cv2.waitKey()
        cv2.destroyAllWindows()

        count += 1
        if count > 5: break